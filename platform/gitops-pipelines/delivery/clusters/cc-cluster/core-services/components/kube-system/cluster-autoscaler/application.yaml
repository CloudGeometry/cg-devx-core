apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: cluster-autoscaler
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "0"
spec:
  project: core
  source:
    repoURL: https://kubernetes.github.io/autoscaler
    chart: cluster-autoscaler
    targetRevision: 9.34.0
    helm:
      values: |-
        ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
        # affinity -- Affinity for pod assignment
        affinity: {}

        # additionalLabels -- Labels to add to each object of the chart.
        additionalLabels: {}

        autoDiscovery:
          # cloudProviders `aws`, `gce`, `azure`, `magnum`, `clusterapi` and `oci` are supported by auto-discovery at this time
          # AWS: Set tags as described in https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md#auto-discovery-setup

          # autoDiscovery.clusterName -- Enable autodiscovery for `cloudProvider=aws`, for groups matching `autoDiscovery.tags`.
          # autoDiscovery.clusterName -- Enable autodiscovery for `cloudProvider=azure`, using tags defined in https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/azure/README.md#auto-discovery-setup.
          # Enable autodiscovery for `cloudProvider=clusterapi`, for groups matching `autoDiscovery.labels`.
          # Enable autodiscovery for `cloudProvider=gce`, but no MIG tagging required.
          # Enable autodiscovery for `cloudProvider=magnum`, for groups matching `autoDiscovery.roles`.
          clusterName: <PRIMARY_CLUSTER_NAME>

          # autoDiscovery.tags -- ASG tags to match, run through `tpl`.
          tags:
            - k8s.io/cluster-autoscaler/enabled
            - k8s.io/cluster-autoscaler/<PRIMARY_CLUSTER_NAME>
          # - kubernetes.io/cluster/{{ .Values.autoDiscovery.clusterName }}

          # autoDiscovery.roles -- Magnum node group roles to match.
          roles:
            - worker

        # awsRegion -- AWS region (required if `cloudProvider=aws`)
        awsRegion: <CLOUD_REGION>

        # cloudProvider -- The cloud provider where the autoscaler runs.
        # Currently only `gce`, `aws`, `azure`, `magnum` and `clusterapi` are supported.
        # `aws` supported for AWS. `gce` for GCE. `azure` for Azure AKS.
        # `magnum` for OpenStack Magnum, `clusterapi` for Cluster API.
        cloudProvider: <CLOUD_PROVIDER>

        # containerSecurityContext -- [Security context for container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
        containerSecurityContext:
          capabilities:
            drop:
            - ALL

        deployment:
          # deployment.annotations -- Annotations to add to the Deployment object.
          annotations: {}

        # dnsPolicy -- Defaults to `ClusterFirst`. Valid values are:
        # `ClusterFirstWithHostNet`, `ClusterFirst`, `Default` or `None`.
        # If autoscaler does not depend on cluster DNS, recommended to set this to `Default`.
        dnsPolicy: ClusterFirst

        # envFromConfigMap -- ConfigMap name to use as envFrom.
        envFromConfigMap: ""

        # envFromSecret -- Secret name to use as envFrom.
        envFromSecret: ""

        # extraArgs -- Additional container arguments.
        # Refer to https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca for the full list of cluster autoscaler
        # parameters and their default values.
        # Everything after the first _ will be ignored allowing the use of multi-string arguments.
        extraArgs:
          logtostderr: true
          stderrthreshold: info
          v: 4
          # write-status-configmap: true
          # status-config-map-name: cluster-autoscaler-status
          # leader-elect: true
          # leader-elect-resource-lock: endpoints
          # skip-nodes-with-local-storage: true
          # expander: random
          # scale-down-enabled: true
          # balance-similar-node-groups: true
          # min-replica-count: 0
          # scale-down-utilization-threshold: 0.5
          # scale-down-non-empty-candidates-count: 30
          # max-node-provision-time: 15m0s
          # scan-interval: 10s
          # scale-down-delay-after-add: 10m
          # scale-down-delay-after-delete: 0s
          # scale-down-delay-after-failure: 3m
          # scale-down-unneeded-time: 10m
          # skip-nodes-with-system-pods: true
          # balancing-ignore-label_1: first-label-to-ignore
          # balancing-ignore-label_2: second-label-to-ignore

        # hostNetwork -- Whether to expose network interfaces of the host machine to pods.
        hostNetwork: false

        # kwokConfigMapName -- configmap for configuring kwok provider
        kwokConfigMapName: "kwok-provider-config"

        # nodeSelector -- Node labels for pod assignment. Ref: https://kubernetes.io/docs/user-guide/node-selection/.
        nodeSelector: {}

        # podAnnotations -- Annotations to add to each pod.
        podAnnotations: {}

        # podDisruptionBudget -- Pod disruption budget.
        podDisruptionBudget:
          maxUnavailable: 1
          # minAvailable: 2

        # podLabels -- Labels to add to each pod.
        podLabels: {}

        # priorityClassName -- priorityClassName
        priorityClassName: "system-cluster-critical"

        ## Custom PrometheusRule to be defined
        ## The value is evaluated as a template, so, for example, the value can depend on .Release or .Chart
        ## ref: https://github.com/coreos/prometheus-operator#customresourcedefinitions
        prometheusRule:
          # prometheusRule.enabled -- If true, creates a Prometheus Operator PrometheusRule.
          enabled: true
          # prometheusRule.additionalLabels -- Additional labels to be set in metadata.
          additionalLabels: {}
          # prometheusRule.namespace -- Namespace which Prometheus is running in.
          namespace: monitoring
          # prometheusRule.interval -- How often rules in the group are evaluated (falls back to `global.evaluation_interval` if not set).
          interval: null
          # prometheusRule.rules -- Rules spec template (see https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/api.md#rule).
          rules: []

        rbac:
          # rbac.create -- If `true`, create and use RBAC resources.
          create: true
          # rbac.pspEnabled -- If `true`, creates and uses RBAC resources required in the cluster with [Pod Security Policies](https://kubernetes.io/docs/concepts/policy/pod-security-policy/) enabled.
          # Must be used with `rbac.create` set to `true`.
          pspEnabled: false
          # rbac.clusterScoped -- if set to false will only provision RBAC to alter resources in the current namespace. Most useful for Cluster-API
          clusterScoped: true
          serviceAccount:
            # rbac.serviceAccount.annotations -- Additional Service Account annotations.
            annotations:
              <K8S_ROLE_MAPPING>: “<CLUSTER_AUTOSCALER_IAM_ROLE_RN>”
            # rbac.serviceAccount.create -- If `true` and `rbac.create` is also true, a Service Account will be created.
            create: true
            # rbac.serviceAccount.name -- The name of the ServiceAccount to use. If not set and create is `true`, a name is generated using the fullname template.
            name:
              cluster-autoscaler
            # rbac.serviceAccount.automountServiceAccountToken -- Automount API credentials for a Service Account.
            automountServiceAccountToken: true

        # replicaCount -- Desired number of pods
        replicaCount: 1

        # resources -- Pod resource requests and limits.
        resources:
          limits:
            cpu: 100m
            memory: 300Mi
          requests:
            cpu: 100m
            memory: 300Mi

        # revisionHistoryLimit -- The number of revisions to keep.
        revisionHistoryLimit: 10

        # securityContext -- [Security context for pod](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
          runAsGroup: 1001

        service:
          # service.create -- If `true`, a Service will be created.
          create: true
          # service.annotations -- Annotations to add to service
          annotations: {}
          # service.labels -- Labels to add to service
          labels: {}
          # service.externalIPs -- List of IP addresses at which the service is available. Ref: https://kubernetes.io/docs/user-guide/services/#external-ips.
          externalIPs: []

          # service.loadBalancerIP -- IP address to assign to load balancer (if supported).
          loadBalancerIP: ""
          # service.loadBalancerSourceRanges -- List of IP CIDRs allowed access to load balancer (if supported).
          loadBalancerSourceRanges: []
          # service.servicePort -- Service port to expose.
          servicePort: 8085
          # service.portName -- Name for service port.
          portName: http
          # service.type -- Type of service to create.
          type: ClusterIP

        ## Are you using Prometheus Operator?
        serviceMonitor:
          # serviceMonitor.enabled -- If true, creates a Prometheus Operator ServiceMonitor.
          enabled: true
          # serviceMonitor.interval -- Interval that Prometheus scrapes Cluster Autoscaler metrics.
          interval: 10s
          # serviceMonitor.namespace -- Namespace which Prometheus is running in.
          namespace: monitoring
          ## [Prometheus Selector Label](https://github.com/helm/charts/tree/master/stable/prometheus-operator#prometheus-operator-1)
          ## [Kube Prometheus Selector Label](https://github.com/helm/charts/tree/master/stable/prometheus-operator#exporters)
          # serviceMonitor.selector -- Default to kube-prometheus install (CoreOS recommended), but should be set according to Prometheus install.
          selector:
            release: prometheus-operator
          # serviceMonitor.path -- The path to scrape for metrics; autoscaler exposes `/metrics` (this is standard)
          path: /metrics
          # serviceMonitor.annotations -- Annotations to add to service monitor
          annotations: {}
          ## [RelabelConfig](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#monitoring.coreos.com/v1.RelabelConfig)
          # serviceMonitor.metricRelabelings -- MetricRelabelConfigs to apply to samples before ingestion.
          metricRelabelings: {}

        # tolerations -- List of node taints to tolerate (requires Kubernetes >= 1.6).
        tolerations: []

        # topologySpreadConstraints -- You can use topology spread constraints to control how Pods are spread across your cluster among failure-domains such as regions, zones, nodes, and other user-defined topology domains. (requires Kubernetes >= 1.19).
        topologySpreadConstraints: []
          # - maxSkew: 1
          #   topologyKey: topology.kubernetes.io/zone
          #   whenUnsatisfiable: DoNotSchedule
          #   labelSelector:
          #     matchLabels:
          #       app.kubernetes.io/instance: cluster-autoscaler

        # updateStrategy -- [Deployment update strategy](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy)
        updateStrategy: {}
          # rollingUpdate:
          #   maxSurge: 1
          #   maxUnavailable: 0
          # type: RollingUpdate

  destination:
    server: https://kubernetes.default.svc
    namespace: cluster-autoscaler
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
